乐观锁和悲观锁

双重校验锁单例模式（线程安全）



# 能聊聊你对CAS的理解以及其底层实现原理可以吗？





# 你对JDK中的AQS理解吗，AQS的实现原理是什么？

AQS 的全称为（`AbstractQueuedSynchronizer`），AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出大量应用广泛的同步器，比如我们提到的 `ReentrantLock`，`Semaphore`，其他的诸如 `ReentrantReadWriteLock`，`SynchronousQueue`，`FutureTask` 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。

<img src="C:\Users\yaoya\AppData\Roaming\Typora\typora-user-images\image-20211205133645232.png" alt="image-20211205133645232" style="zoom: 33%;" />



# ConcurrentHashMap 实现线程安全的底层原理到底是什么?

# 说说线程池的底层实现原理可以吗？





# 你知道如果线程池的队列满了之后，会发生什么事吗？

首先线程池有4中饱和策略：

- **`ThreadPoolExecutor.AbortPolicy`：** 抛出 `RejectedExecutionException`来拒绝新任务的处理。
- **`ThreadPoolExecutor.CallerRunsPolicy`：** 调用执行自己的线程运行任务，也就是直接在调用`execute`方法的线程中运行(`run`)被拒绝的任务，如果执行程序已关闭，则会丢弃该任务。因此这种策略会降低对于新任务提交速度，影响程序的整体性能。如果您的应用程序可以承受此延迟并且你要求任何一个任务请求都要被执行的话，你可以选择这个策略。
- **`ThreadPoolExecutor.DiscardPolicy`：** 不处理新任务，直接丢弃掉。
- **`ThreadPoolExecutor.DiscardOldestPolicy`：** 此策略将丢弃最早的未处理的任务请求。

如果负载过高，使用无界队列，可能内存崩溃，如果使用有界队列，CPU负载过高也是不太好。还可以自定义reject策略：如果线程池无法执行更多的任务了，建议将线程任务写入到磁盘里去，在后台专门启动一个线程，后续等线程池的工作负载降低了，可以慢慢的从磁盘里读取之前持久化的任务，然后从新提交到线程池里去执行。



# 如果线上机器突然宕机，线程池的阻塞队列中阻塞的任务会怎么样？

机器宕机，队列中积压的任务肯定会丢失。解决方法，线程任务提交之前，先持久化到数据库中，设置状态：未提交、已提交、已完成。



# 谈谈你对java内存模型的理解可以吗？



# 你知道java内存模型中的原子性、有序性、可见性是什么吗？



# 能从底层角度聊聊volatile关键字的原理吗？



# 你知道指令重排以及happens -before 原则是什么吗?



# volatile 底层是如何基于内存屏障保证可见性和有序性的?